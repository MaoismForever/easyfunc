<javaelement>
	<package>
		java.io
	</package>
	<type>
		<name>
			public class BufferedReader  extends Reader
		</name>
		<description>
			Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines. The buffer size may be specified, or the default size may be used. The default is large enough for most purposes. In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,    BufferedReader in     = new BufferedReader(new FileReader("foo.in"));   will buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient. Programs that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader.
		</description>
		<methods>
			<method>
				<name>
					public BufferedReader(Reader in,                int sz)
				</name>
				<description>
					Creates a buffering character-input stream that uses an input buffer of the specified size.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedReader(Reader in)
				</name>
				<description>
					Creates a buffering character-input stream that uses a default-sized input buffer.
				</description>
				
			</method>
			<method>
				<name>
					public int read()           throws IOException
				</name>
				<description>
					Reads a single character.
				</description>
				
			</method>
			<method>
				<name>
					public int read(char[] cbuf,         int off,         int len)           throws IOException
				</name>
				<description>
					Reads characters into a portion of an array. This method implements the general contract of the corresponding read method of the Reader class. As an additional convenience, it attempts to read as many characters as possible by repeatedly invoking the read method of the underlying stream. This iterated read continues until one of the following conditions becomes true: The specified number of characters have been read, The read method of the underlying stream returns -1, indicating end-of-file, or The ready method of the underlying stream returns false, indicating that further input requests would block. If the first read on the underlying stream returns -1 to indicate end-of-file then this method returns -1. Otherwise this method returns the number of characters actually read. Subclasses of this class are encouraged, but not required, to attempt to read as many characters as possible in the same fashion. Ordinarily this method takes characters from this stream's character buffer, filling it from the underlying stream as necessary. If, however, the buffer is empty, the mark is not valid, and the requested length is at least as large as the buffer, then this method will read characters directly from the underlying stream into the given array. Thus redundant BufferedReaders will not copy data unnecessarily.
				</description>
				
			</method>
			<method>
				<name>
					public String readLine()                  throws IOException
				</name>
				<description>
					Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a linefeed.
				</description>
				
			</method>
			<method>
				<name>
					public long skip(long n)            throws IOException
				</name>
				<description>
					Skips characters.
				</description>
				
			</method>
			<method>
				<name>
					public boolean ready()                throws IOException
				</name>
				<description>
					Tells whether this stream is ready to be read. A buffered character stream is ready if the buffer is not empty, or if the underlying character stream is ready.
				</description>
				
			</method>
			<method>
				<name>
					public boolean markSupported()
				</name>
				<description>
					Tells whether this stream supports the mark() operation, which it does.
				</description>
				
			</method>
			<method>
				<name>
					public void mark(int readAheadLimit)            throws IOException
				</name>
				<description>
					Marks the present position in the stream. Subsequent calls to reset() will attempt to reposition the stream to this point.
				</description>
				
			</method>
			<method>
				<name>
					public void reset()             throws IOException
				</name>
				<description>
					Resets the stream to the most recent mark.
				</description>
				
			</method>
			<method>
				<name>
					public void close()             throws IOException
				</name>
				<description>
					Description copied from class: Reader Closes the stream and releases any system resources associated with it. Once the stream has been closed, further read(), ready(), mark(), reset(), or skip() invocations will throw an IOException. Closing a previously closed stream has no effect.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
