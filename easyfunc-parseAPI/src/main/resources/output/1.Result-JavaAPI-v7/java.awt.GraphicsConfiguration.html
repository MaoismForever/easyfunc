<javaelement>
	<package>
		java.awt
	</package>
	<type>
		<name>
			public abstract class GraphicsConfiguration  extends Object
		</name>
		<description>
			The GraphicsConfiguration class describes the characteristics of a graphics destination such as a printer or monitor. There can be many GraphicsConfiguration objects associated with a single graphics device, representing different drawing modes or capabilities. The corresponding native structure will vary from platform to platform. For example, on X11 windowing systems, each visual is a different GraphicsConfiguration. On Microsoft Windows, GraphicsConfigurations represent PixelFormats available in the current resolution and color depth. In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of the GraphicsConfiguration objects are relative to the virtual coordinate system. When setting the location of a component, use getBounds to get the bounds of the desired GraphicsConfiguration and offset the location with the coordinates of the GraphicsConfiguration, as the following code sample illustrates:         Frame f = new Frame(gc);  // where gc is a GraphicsConfiguration        Rectangle bounds = gc.getBounds();        f.setLocation(10 + bounds.x, 10 + bounds.y); To determine if your environment is a virtual device environment, call getBounds on all of the GraphicsConfiguration objects in your system. If any of the origins of the returned bounds is not (0, 0), your environment is a virtual device environment. You can also use getBounds to determine the bounds of the virtual device. To do this, first call getBounds on all of the GraphicsConfiguration objects in your system. Then calculate the union of all of the bounds returned from the calls to getBounds. The union is the bounds of the virtual device. The following code sample calculates the bounds of the virtual device.         Rectangle virtualBounds = new Rectangle();        GraphicsEnvironment ge = GraphicsEnvironment.                getLocalGraphicsEnvironment();        GraphicsDevice[] gs =                ge.getScreenDevices();        for (int j = 0; j < gs.length; j++) {            GraphicsDevice gd = gs[j];            GraphicsConfiguration[] gc =                gd.getConfigurations();            for (int i=0; i < gc.length; i++) {                virtualBounds =                    virtualBounds.union(gc[i].getBounds());            }        }
		</description>
		<methods>
			<method>
				<name>
					protected GraphicsConfiguration()
				</name>
				<description>
					This is an abstract class that cannot be instantiated directly. Instances must be obtained from a suitable factory or query method.
				</description>
				
			</method>
			<method>
				<name>
					public abstract GraphicsDevice getDevice()
				</name>
				<description>
					Returns the GraphicsDevice associated with this GraphicsConfiguration.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage createCompatibleImage(int width,                                    int height)
				</name>
				<description>
					Returns a BufferedImage with a data layout and color model compatible with this GraphicsConfiguration. This method has nothing to do with memory-mapping a device. The returned BufferedImage has a layout and color model that is closest to this native device configuration and can therefore be optimally blitted to this device.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage createCompatibleImage(int width,                                    int height,                                    int transparency)
				</name>
				<description>
					Returns a BufferedImage that supports the specified transparency and has a data layout and color model compatible with this GraphicsConfiguration. This method has nothing to do with memory-mapping a device. The returned BufferedImage has a layout and color model that can be optimally blitted to a device with this GraphicsConfiguration.
				</description>
				
			</method>
			<method>
				<name>
					public VolatileImage createCompatibleVolatileImage(int width,                                            int height)
				</name>
				<description>
					Returns a VolatileImage with a data layout and color model compatible with this GraphicsConfiguration. The returned VolatileImage may have data that is stored optimally for the underlying graphics device and may therefore benefit from platform-specific rendering acceleration.
				</description>
				
			</method>
			<method>
				<name>
					public VolatileImage createCompatibleVolatileImage(int width,                                            int height,                                            int transparency)
				</name>
				<description>
					Returns a VolatileImage with a data layout and color model compatible with this GraphicsConfiguration. The returned VolatileImage may have data that is stored optimally for the underlying graphics device and may therefore benefit from platform-specific rendering acceleration.
				</description>
				
			</method>
			<method>
				<name>
					public VolatileImage createCompatibleVolatileImage(int width,                                            int height,                                            ImageCapabilities caps)                                              throws AWTException
				</name>
				<description>
					Returns a VolatileImage with a data layout and color model compatible with this GraphicsConfiguration, using the specified image capabilities. If the caps parameter is null, it is effectively ignored and this method will create a VolatileImage without regard to ImageCapabilities constraints. The returned VolatileImage has a layout and color model that is closest to this native device configuration and can therefore be optimally blitted to this device.
				</description>
				
			</method>
			<method>
				<name>
					public VolatileImage createCompatibleVolatileImage(int width,                                            int height,                                            ImageCapabilities caps,                                            int transparency)                                              throws AWTException
				</name>
				<description>
					Returns a VolatileImage with a data layout and color model compatible with this GraphicsConfiguration, using the specified image capabilities and transparency value. If the caps parameter is null, it is effectively ignored and this method will create a VolatileImage without regard to ImageCapabilities constraints. The returned VolatileImage has a layout and color model that is closest to this native device configuration and can therefore be optimally blitted to this device.
				</description>
				
			</method>
			<method>
				<name>
					public abstract ColorModel getColorModel()
				</name>
				<description>
					Returns the ColorModel associated with this GraphicsConfiguration.
				</description>
				
			</method>
			<method>
				<name>
					public abstract ColorModel getColorModel(int transparency)
				</name>
				<description>
					Returns the ColorModel associated with this GraphicsConfiguration that supports the specified transparency.
				</description>
				
			</method>
			<method>
				<name>
					public abstract AffineTransform getDefaultTransform()
				</name>
				<description>
					Returns the default AffineTransform for this GraphicsConfiguration. This AffineTransform is typically the Identity transform for most normal screens. The default AffineTransform maps coordinates onto the device such that 72 user space coordinate units measure approximately 1 inch in device space. The normalizing transform can be used to make this mapping more exact. Coordinates in the coordinate space defined by the default AffineTransform for screen and printer devices have the origin in the upper left-hand corner of the target region of the device, with X coordinates increasing to the right and Y coordinates increasing downwards. For image buffers not associated with a device, such as those not created by createCompatibleImage, this AffineTransform is the Identity transform.
				</description>
				
			</method>
			<method>
				<name>
					public abstract AffineTransform getNormalizingTransform()
				</name>
				<description>
					Returns a AffineTransform that can be concatenated with the default AffineTransform of a GraphicsConfiguration so that 72 units in user space equals 1 inch in device space. For a particular Graphics2D, g, one can reset the transformation to create such a mapping by using the following pseudocode:         GraphicsConfiguration gc = g.getDeviceConfiguration();          g.setTransform(gc.getDefaultTransform());        g.transform(gc.getNormalizingTransform());   Note that sometimes this AffineTransform is identity, such as for printers or metafile output, and that this AffineTransform is only as accurate as the information supplied by the underlying system. For image buffers not associated with a device, such as those not created by createCompatibleImage, this AffineTransform is the Identity transform since there is no valid distance measurement.
				</description>
				
			</method>
			<method>
				<name>
					public abstract Rectangle getBounds()
				</name>
				<description>
					Returns the bounds of the GraphicsConfiguration in the device coordinates. In a multi-screen environment with a virtual device, the bounds can have negative X or Y origins.
				</description>
				
			</method>
			<method>
				<name>
					public BufferCapabilities getBufferCapabilities()
				</name>
				<description>
					Returns the buffering capabilities of this GraphicsConfiguration.
				</description>
				
			</method>
			<method>
				<name>
					public ImageCapabilities getImageCapabilities()
				</name>
				<description>
					Returns the image capabilities of this GraphicsConfiguration.
				</description>
				
			</method>
			<method>
				<name>
					public boolean isTranslucencyCapable()
				</name>
				<description>
					Returns whether this GraphicsConfiguration supports the PERPIXEL_TRANSLUCENT kind of translucency.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
