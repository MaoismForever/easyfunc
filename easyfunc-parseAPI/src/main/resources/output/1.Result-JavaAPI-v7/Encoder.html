<javaelement>
	<package>
		java.beans
	</package>
	<type>
		<name>
			public class Encoder  extends Object
		</name>
		<description>
			An Encoder is a class which can be used to create files or streams that encode the state of a collection of JavaBeans in terms of their public APIs. The Encoder, in conjunction with its persistence delegates, is responsible for breaking the object graph down into a series of Statementss and Expressions which can be used to create it. A subclass typically provides a syntax for these expressions using some human readable form - like Java source code or XML.
		</description>
		<methods>
			<method>
				<name>
					public Encoder()
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					protected void writeObject(Object o)
				</name>
				<description>
					Write the specified object to the output stream. The serialized form will denote a series of expressions, the combined effect of which will create an equivalent object when the input stream is read. By default, the object is assumed to be a JavaBean with a nullary constructor, whose state is defined by the matching pairs of "setter" and "getter" methods returned by the Introspector.
				</description>
				
			</method>
			<method>
				<name>
					public void setExceptionListener(ExceptionListener exceptionListener)
				</name>
				<description>
					Sets the exception handler for this stream to exceptionListener. The exception handler is notified when this stream catches recoverable exceptions.
				</description>
				
			</method>
			<method>
				<name>
					public ExceptionListener getExceptionListener()
				</name>
				<description>
					Gets the exception handler for this stream.
				</description>
				
			</method>
			<method>
				<name>
					public PersistenceDelegate getPersistenceDelegate(Class<?> type)
				</name>
				<description>
					Returns the persistence delegate for the given type. The persistence delegate is calculated by applying the following rules in order: If a persistence delegate is associated with the given type by using the setPersistenceDelegate(java.lang.Class<?>, java.beans.PersistenceDelegate) method it is returned. A persistence delegate is then looked up by the name composed of the the fully qualified name of the given type and the "PersistenceDelegate" postfix. For example, a persistence delegate for the Bean class should be named BeanPersistenceDelegate and located in the same package.    public class Bean { ... }   public class BeanPersistenceDelegate { ... } The instance of the BeanPersistenceDelegate class is returned for the Bean class. If the type is null, a shared internal persistence delegate is returned that encodes null value. If the type is a enum declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names. If the type is a primitive type or the corresponding wrapper, a shared internal persistence delegate is returned that encodes values of the given type. If the type is an array, a shared internal persistence delegate is returned that encodes an array of the appropriate type and length, and each of its elements as if they are properties. If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class<?>[], java.lang.reflect.InvocationHandler) method. If the BeanInfo for this type has a BeanDescriptor which defined a "persistenceDelegate" attribute, the value of this named attribute is returned. In all other cases the default persistence delegate is returned. The default persistence delegate assumes the type is a JavaBean, implying that it has a default constructor and that its state may be characterized by the matching pairs of "setter" and "getter" methods returned by the Introspector class. The default constructor is the constructor with the greatest number of parameters that has the ConstructorProperties annotation. If none of the constructors has the ConstructorProperties annotation, then the nullary constructor (constructor with no parameters) will be used. For example, in the following code fragment, the nullary constructor for the Foo class will be used, while the two-parameter constructor for the Bar class will be used.    public class Foo {       public Foo() { ... }       public Foo(int x) { ... }   }   public class Bar {       public Bar() { ... }       @ConstructorProperties({"x"})       public Bar(int x) { ... }       @ConstructorProperties({"x", "y"})       public Bar(int x, int y) { ... }   }
				</description>
				
			</method>
			<method>
				<name>
					public void setPersistenceDelegate(Class<?> type,                            PersistenceDelegate delegate)
				</name>
				<description>
					Associates the specified persistence delegate with the given type.
				</description>
				
			</method>
			<method>
				<name>
					public Object remove(Object oldInstance)
				</name>
				<description>
					Removes the entry for this instance, returning the old entry.
				</description>
				
			</method>
			<method>
				<name>
					public Object get(Object oldInstance)
				</name>
				<description>
					Returns a tentative value for oldInstance in the environment created by this stream. A persistence delegate can use its mutatesTo method to determine whether this value may be initialized to form the equivalent object at the output or whether a new object must be instantiated afresh. If the stream has not yet seen this value, null is returned.
				</description>
				
			</method>
			<method>
				<name>
					public void writeStatement(Statement oldStm)
				</name>
				<description>
					Writes statement oldStm to the stream. The oldStm should be written entirely in terms of the callers environment, i.e. the target and all arguments should be part of the object graph being written. These expressions represent a series of "what happened" expressions which tell the output stream how to produce an object graph like the original. The implementation of this method will produce a second expression to represent the same expression in an environment that will exist when the stream is read. This is achieved simply by calling writeObject on the target and all the arguments and building a new expression with the results.
				</description>
				
			</method>
			<method>
				<name>
					public void writeExpression(Expression oldExp)
				</name>
				<description>
					The implementation first checks to see if an expression with this value has already been written. If not, the expression is cloned, using the same procedure as writeStatement, and the value of this expression is reconciled with the value of the cloned expression by calling writeObject.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
