<javaelement>
	<package>
		java.awt.image
	</package>
	<type>
		<name>
			public class BufferedImage  extends Image  implements WritableRenderedImage, Transparency
		</name>
		<description>
			The BufferedImage subclass describes an Image with an accessible buffer of image data. A BufferedImage is comprised of a ColorModel and a Raster of image data. The number and types of bands in the SampleModel of the Raster must match the number and types required by the ColorModel to represent its color and alpha components. All BufferedImage objects have an upper left corner coordinate of (0, 0). Any Raster used to construct a BufferedImage must therefore have minX=0 and minY=0. This class relies on the data fetching and setting methods of Raster, and on the color characterization methods of ColorModel.
		</description>
		<methods>
			<method>
				<name>
					public static final int TYPE_CUSTOM
				</name>
				<description>
					Image type is not recognized so it must be a customized image. This type is only used as a return value for the getType() method.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_INT_RGB
				</name>
				<description>
					Represents an image with 8-bit RGB color components packed into integer pixels. The image has a DirectColorModel without alpha. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_INT_ARGB
				</name>
				<description>
					Represents an image with 8-bit RGBA color components packed into integer pixels. The image has a DirectColorModel with alpha. The color data in this image is considered not to be premultiplied with alpha. When this type is used as the imageType argument to a BufferedImage constructor, the created image is consistent with images created in the JDK1.1 and earlier releases.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_INT_ARGB_PRE
				</name>
				<description>
					Represents an image with 8-bit RGBA color components packed into integer pixels. The image has a DirectColorModel with alpha. The color data in this image is considered to be premultiplied with alpha.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_INT_BGR
				</name>
				<description>
					Represents an image with 8-bit RGB color components, corresponding to a Windows- or Solaris- style BGR color model, with the colors Blue, Green, and Red packed into integer pixels. There is no alpha. The image has a DirectColorModel. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_3BYTE_BGR
				</name>
				<description>
					Represents an image with 8-bit RGB color components, corresponding to a Windows-style BGR color model) with the colors Blue, Green, and Red stored in 3 bytes. There is no alpha. The image has a ComponentColorModel. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_4BYTE_ABGR
				</name>
				<description>
					Represents an image with 8-bit RGBA color components with the colors Blue, Green, and Red stored in 3 bytes and 1 byte of alpha. The image has a ComponentColorModel with alpha. The color data in this image is considered not to be premultiplied with alpha. The byte data is interleaved in a single byte array in the order A, B, G, R from lower to higher byte addresses within each pixel.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_4BYTE_ABGR_PRE
				</name>
				<description>
					Represents an image with 8-bit RGBA color components with the colors Blue, Green, and Red stored in 3 bytes and 1 byte of alpha. The image has a ComponentColorModel with alpha. The color data in this image is considered to be premultiplied with alpha. The byte data is interleaved in a single byte array in the order A, B, G, R from lower to higher byte addresses within each pixel.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_USHORT_565_RGB
				</name>
				<description>
					Represents an image with 5-6-5 RGB color components (5-bits red, 6-bits green, 5-bits blue) with no alpha. This image has a DirectColorModel. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_USHORT_555_RGB
				</name>
				<description>
					Represents an image with 5-5-5 RGB color components (5-bits red, 5-bits green, 5-bits blue) with no alpha. This image has a DirectColorModel. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_BYTE_GRAY
				</name>
				<description>
					Represents a unsigned byte grayscale image, non-indexed. This image has a ComponentColorModel with a CS_GRAY ColorSpace. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_USHORT_GRAY
				</name>
				<description>
					Represents an unsigned short grayscale image, non-indexed). This image has a ComponentColorModel with a CS_GRAY ColorSpace. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_BYTE_BINARY
				</name>
				<description>
					Represents an opaque byte-packed 1, 2, or 4 bit image. The image has an IndexColorModel without alpha. When this type is used as the imageType argument to the BufferedImage constructor that takes an imageType argument but no ColorModel argument, a 1-bit image is created with an IndexColorModel with two colors in the default sRGB ColorSpace: {0, 0, 0} and {255, 255, 255}. Images with 2 or 4 bits per pixel may be constructed via the BufferedImage constructor that takes a ColorModel argument by supplying a ColorModel with an appropriate map size. Images with 8 bits per pixel should use the image types TYPE_BYTE_INDEXED or TYPE_BYTE_GRAY depending on their ColorModel. When color data is stored in an image of this type, the closest color in the colormap is determined by the IndexColorModel and the resulting index is stored. Approximation and loss of alpha or color components can result, depending on the colors in the IndexColorModel colormap.
				</description>
				
			</method>
			<method>
				<name>
					public static final int TYPE_BYTE_INDEXED
				</name>
				<description>
					Represents an indexed byte image. When this type is used as the imageType argument to the BufferedImage constructor that takes an imageType argument but no ColorModel argument, an IndexColorModel is created with a 256-color 6/6/6 color cube palette with the rest of the colors from 216-255 populated by grayscale values in the default sRGB ColorSpace. When color data is stored in an image of this type, the closest color in the colormap is determined by the IndexColorModel and the resulting index is stored. Approximation and loss of alpha or color components can result, depending on the colors in the IndexColorModel colormap.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage(int width,               int height,               int imageType)
				</name>
				<description>
					Constructs a BufferedImage of one of the predefined image types. The ColorSpace for the image is the default sRGB space.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage(int width,               int height,               int imageType,               IndexColorModel cm)
				</name>
				<description>
					Constructs a BufferedImage of one of the predefined image types: TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED. If the image type is TYPE_BYTE_BINARY, the number of entries in the color model is used to determine whether the image should have 1, 2, or 4 bits per pixel. If the color model has 1 or 2 entries, the image will have 1 bit per pixel. If it has 3 or 4 entries, the image with have 2 bits per pixel. If it has between 5 and 16 entries, the image will have 4 bits per pixel. Otherwise, an IllegalArgumentException will be thrown.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage(ColorModel cm,               WritableRaster raster,               boolean isRasterPremultiplied,               Hashtable<?,?> properties)
				</name>
				<description>
					Constructs a new BufferedImage with a specified ColorModel and Raster. If the number and types of bands in the SampleModel of the Raster do not match the number and types required by the ColorModel to represent its color and alpha components, a RasterFormatException is thrown. This method can multiply or divide the color Raster data by alpha to match the alphaPremultiplied state in the ColorModel. Properties for this BufferedImage can be established by passing in a Hashtable of String/Object pairs.
				</description>
				
			</method>
			<method>
				<name>
					public int getType()
				</name>
				<description>
					Returns the image type. If it is not one of the known types, TYPE_CUSTOM is returned.
				</description>
				
			</method>
			<method>
				<name>
					public ColorModel getColorModel()
				</name>
				<description>
					Returns the ColorModel.
				</description>
				
			</method>
			<method>
				<name>
					public WritableRaster getRaster()
				</name>
				<description>
					Returns the WritableRaster.
				</description>
				
			</method>
			<method>
				<name>
					public WritableRaster getAlphaRaster()
				</name>
				<description>
					Returns a WritableRaster representing the alpha channel for BufferedImage objects with ColorModel objects that support a separate spatial alpha channel, such as ComponentColorModel and DirectColorModel. Returns null if there is no alpha channel associated with the ColorModel in this image. This method assumes that for all ColorModel objects other than IndexColorModel, if the ColorModel supports alpha, there is a separate alpha channel which is stored as the last band of image data. If the image uses an IndexColorModel that has alpha in the lookup table, this method returns null since there is no spatially discrete alpha channel. This method creates a new WritableRaster, but shares the data array.
				</description>
				
			</method>
			<method>
				<name>
					public int getRGB(int x,           int y)
				</name>
				<description>
					Returns an integer pixel in the default RGB color model (TYPE_INT_ARGB) and default sRGB colorspace. Color conversion takes place if this default model does not match the image ColorModel. There are only 8-bits of precision for each color component in the returned data when using this method. An ArrayOutOfBoundsException may be thrown if the coordinates are not in bounds. However, explicit bounds checking is not guaranteed.
				</description>
				
			</method>
			<method>
				<name>
					public int[] getRGB(int startX,             int startY,             int w,             int h,             int[] rgbArray,             int offset,             int scansize)
				</name>
				<description>
					Returns an array of integer pixels in the default RGB color model (TYPE_INT_ARGB) and default sRGB color space, from a portion of the image data. Color conversion takes place if the default model does not match the image ColorModel. There are only 8-bits of precision for each color component in the returned data when using this method. With a specified coordinate (x, y) in the image, the ARGB pixel can be accessed in this way:       pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)]; An ArrayOutOfBoundsException may be thrown if the region is not in bounds. However, explicit bounds checking is not guaranteed.
				</description>
				
			</method>
			<method>
				<name>
					public void setRGB(int x,            int y,            int rgb)
				</name>
				<description>
					Sets a pixel in this BufferedImage to the specified RGB value. The pixel is assumed to be in the default RGB color model, TYPE_INT_ARGB, and default sRGB color space. For images with an IndexColorModel, the index with the nearest color is chosen. An ArrayOutOfBoundsException may be thrown if the coordinates are not in bounds. However, explicit bounds checking is not guaranteed.
				</description>
				
			</method>
			<method>
				<name>
					public void setRGB(int startX,            int startY,            int w,            int h,            int[] rgbArray,            int offset,            int scansize)
				</name>
				<description>
					Sets an array of integer pixels in the default RGB color model (TYPE_INT_ARGB) and default sRGB color space, into a portion of the image data. Color conversion takes place if the default model does not match the image ColorModel. There are only 8-bits of precision for each color component in the returned data when using this method. With a specified coordinate (x, y) in the this image, the ARGB pixel can be accessed in this way:       pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)];   WARNING: No dithering takes place. An ArrayOutOfBoundsException may be thrown if the region is not in bounds. However, explicit bounds checking is not guaranteed.
				</description>
				
			</method>
			<method>
				<name>
					public int getWidth()
				</name>
				<description>
					Returns the width of the BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public int getHeight()
				</name>
				<description>
					Returns the height of the BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public int getWidth(ImageObserver observer)
				</name>
				<description>
					Returns the width of the BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public int getHeight(ImageObserver observer)
				</name>
				<description>
					Returns the height of the BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public ImageProducer getSource()
				</name>
				<description>
					Returns the object that produces the pixels for the image.
				</description>
				
			</method>
			<method>
				<name>
					public Object getProperty(String name,                   ImageObserver observer)
				</name>
				<description>
					Returns a property of the image by name. Individual property names are defined by the various image formats. If a property is not defined for a particular image, this method returns the UndefinedProperty field. If the properties for this image are not yet known, then this method returns null and the ImageObserver object is notified later. The property name "comment" should be used to store an optional comment that can be presented to the user as a description of the image, its source, or its author.
				</description>
				
			</method>
			<method>
				<name>
					public Object getProperty(String name)
				</name>
				<description>
					Returns a property of the image by name.
				</description>
				
			</method>
			<method>
				<name>
					public Graphics getGraphics()
				</name>
				<description>
					This method returns a Graphics2D, but is here for backwards compatibility. createGraphics is more convenient, since it is declared to return a Graphics2D.
				</description>
				
			</method>
			<method>
				<name>
					public Graphics2D createGraphics()
				</name>
				<description>
					Creates a Graphics2D, which can be used to draw into this BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public BufferedImage getSubimage(int x,                          int y,                          int w,                          int h)
				</name>
				<description>
					Returns a subimage defined by a specified rectangular region. The returned BufferedImage shares the same data array as the original image.
				</description>
				
			</method>
			<method>
				<name>
					public boolean isAlphaPremultiplied()
				</name>
				<description>
					Returns whether or not the alpha has been premultiplied. It returns false if there is no alpha.
				</description>
				
			</method>
			<method>
				<name>
					public void coerceData(boolean isAlphaPremultiplied)
				</name>
				<description>
					Forces the data to match the state specified in the isAlphaPremultiplied variable. It may multiply or divide the color raster data by alpha, or do nothing if the data is in the correct state.
				</description>
				
			</method>
			<method>
				<name>
					public String toString()
				</name>
				<description>
					Returns a String representation of this BufferedImage object and its values.
				</description>
				
			</method>
			<method>
				<name>
					public Vector<RenderedImage> getSources()
				</name>
				<description>
					Returns a Vector of RenderedImage objects that are the immediate sources, not the sources of these immediate sources, of image data for this BufferedImage. This method returns null if the BufferedImage has no information about its immediate sources. It returns an empty Vector if the BufferedImage has no immediate sources.
				</description>
				
			</method>
			<method>
				<name>
					public String[] getPropertyNames()
				</name>
				<description>
					Returns an array of names recognized by getProperty(String) or null, if no property names are recognized.
				</description>
				
			</method>
			<method>
				<name>
					public int getMinX()
				</name>
				<description>
					Returns the minimum x coordinate of this BufferedImage. This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public int getMinY()
				</name>
				<description>
					Returns the minimum y coordinate of this BufferedImage. This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public SampleModel getSampleModel()
				</name>
				<description>
					Returns the SampleModel associated with this BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public int getNumXTiles()
				</name>
				<description>
					Returns the number of tiles in the x direction. This is always one.
				</description>
				
			</method>
			<method>
				<name>
					public int getNumYTiles()
				</name>
				<description>
					Returns the number of tiles in the y direction. This is always one.
				</description>
				
			</method>
			<method>
				<name>
					public int getMinTileX()
				</name>
				<description>
					Returns the minimum tile index in the x direction. This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public int getMinTileY()
				</name>
				<description>
					Returns the minimum tile index in the y direction. This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public int getTileWidth()
				</name>
				<description>
					Returns the tile width in pixels.
				</description>
				
			</method>
			<method>
				<name>
					public int getTileHeight()
				</name>
				<description>
					Returns the tile height in pixels.
				</description>
				
			</method>
			<method>
				<name>
					public int getTileGridXOffset()
				</name>
				<description>
					Returns the x offset of the tile grid relative to the origin, For example, the x coordinate of the location of tile (0, 0). This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public int getTileGridYOffset()
				</name>
				<description>
					Returns the y offset of the tile grid relative to the origin, For example, the y coordinate of the location of tile (0, 0). This is always zero.
				</description>
				
			</method>
			<method>
				<name>
					public Raster getTile(int tileX,               int tileY)
				</name>
				<description>
					Returns tile (tileX, tileY). Note that tileX and tileY are indices into the tile array, not pixel locations. The Raster that is returned is live, which means that it is updated if the image is changed.
				</description>
				
			</method>
			<method>
				<name>
					public Raster getData()
				</name>
				<description>
					Returns the image as one large tile. The Raster returned is a copy of the image data is not updated if the image is changed.
				</description>
				
			</method>
			<method>
				<name>
					public Raster getData(Rectangle rect)
				</name>
				<description>
					Computes and returns an arbitrary region of the BufferedImage. The Raster returned is a copy of the image data and is not updated if the image is changed.
				</description>
				
			</method>
			<method>
				<name>
					public WritableRaster copyData(WritableRaster outRaster)
				</name>
				<description>
					Computes an arbitrary rectangular region of the BufferedImage and copies it into a specified WritableRaster. The region to be computed is determined from the bounds of the specified WritableRaster. The specified WritableRaster must have a SampleModel that is compatible with this image. If outRaster is null, an appropriate WritableRaster is created.
				</description>
				
			</method>
			<method>
				<name>
					public void setData(Raster r)
				</name>
				<description>
					Sets a rectangular region of the image to the contents of the specified Raster r, which is assumed to be in the same coordinate space as the BufferedImage. The operation is clipped to the bounds of the BufferedImage.
				</description>
				
			</method>
			<method>
				<name>
					public void addTileObserver(TileObserver to)
				</name>
				<description>
					Adds a tile observer. If the observer is already present, it receives multiple notifications.
				</description>
				
			</method>
			<method>
				<name>
					public void removeTileObserver(TileObserver to)
				</name>
				<description>
					Removes a tile observer. If the observer was not registered, nothing happens. If the observer was registered for multiple notifications, it is now registered for one fewer notification.
				</description>
				
			</method>
			<method>
				<name>
					public boolean isTileWritable(int tileX,                       int tileY)
				</name>
				<description>
					Returns whether or not a tile is currently checked out for writing.
				</description>
				
			</method>
			<method>
				<name>
					public Point[] getWritableTileIndices()
				</name>
				<description>
					Returns an array of Point objects indicating which tiles are checked out for writing. Returns null if none are checked out.
				</description>
				
			</method>
			<method>
				<name>
					public boolean hasTileWriters()
				</name>
				<description>
					Returns whether or not any tile is checked out for writing. Semantically equivalent to    (getWritableTileIndices() != null).
				</description>
				
			</method>
			<method>
				<name>
					public WritableRaster getWritableTile(int tileX,                               int tileY)
				</name>
				<description>
					Checks out a tile for writing. All registered TileObservers are notified when a tile goes from having no writers to having one writer.
				</description>
				
			</method>
			<method>
				<name>
					public void releaseWritableTile(int tileX,                         int tileY)
				</name>
				<description>
					Relinquishes permission to write to a tile. If the caller continues to write to the tile, the results are undefined. Calls to this method should only appear in matching pairs with calls to getWritableTile(int, int). Any other leads to undefined results. All registered TileObservers are notified when a tile goes from having one writer to having no writers.
				</description>
				
			</method>
			<method>
				<name>
					public int getTransparency()
				</name>
				<description>
					Returns the transparency. Returns either OPAQUE, BITMASK, or TRANSLUCENT.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
