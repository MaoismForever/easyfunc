<javaelement>
	<package>
		javax.swing
	</package>
	<type>
		<name>
			public class SpinnerNumberModel  extends AbstractSpinnerModel  implements Serializable
		</name>
		<description>
			A SpinnerModel for sequences of numbers. The upper and lower bounds of the sequence are defined by properties called minimum and maximum. The size of the increase or decrease computed by the nextValue and previousValue methods is defined by a property called stepSize. The minimum and maximum properties can be null to indicate that the sequence has no lower or upper limit. All of the properties in this class are defined in terms of two generic types: Number and Comparable, so that all Java numeric types may be accommodated. Internally, there's only support for values whose type is one of the primitive Number types: Double, Float, Long, Integer, Short, or Byte. To create a SpinnerNumberModel for the integer range zero to one hundred, with fifty as the initial value, one could write:    Integer value = new Integer(50);   Integer min = new Integer(0);   Integer max = new Integer(100);   Integer step = new Integer(1);   SpinnerNumberModel model = new SpinnerNumberModel(value, min, max, step);   int fifty = model.getNumber().intValue();   Spinners for integers and doubles are common, so special constructors for these cases are provided. For example to create the model in the previous example, one could also write:    SpinnerNumberModel model = new SpinnerNumberModel(50, 0, 100, 1);   This model inherits a ChangeListener. The ChangeListeners are notified whenever the model's value, stepSize, minimum, or maximum properties changes.
		</description>
		<methods>
			<method>
				<name>
					public SpinnerNumberModel(Number value,                    Comparable minimum,                    Comparable maximum,                    Number stepSize)
				</name>
				<description>
					Constructs a SpinnerModel that represents a closed sequence of numbers from minimum to maximum. The nextValue and previousValue methods compute elements of the sequence by adding or subtracting stepSize respectively. All of the parameters must be mutually Comparable, value and stepSize must be instances of Integer Long, Float, or Double. The minimum and maximum parameters can be null to indicate that the range doesn't have an upper or lower bound. If value or stepSize is null, or if both minimum and maximum are specified and mininum > maximum then an IllegalArgumentException is thrown. Similarly if (minimum <= value <= maximum) is false, an IllegalArgumentException is thrown.
				</description>
				
			</method>
			<method>
				<name>
					public SpinnerNumberModel(int value,                    int minimum,                    int maximum,                    int stepSize)
				</name>
				<description>
					Constructs a SpinnerNumberModel with the specified value, minimum/maximum bounds, and stepSize.
				</description>
				
			</method>
			<method>
				<name>
					public SpinnerNumberModel(double value,                    double minimum,                    double maximum,                    double stepSize)
				</name>
				<description>
					Constructs a SpinnerNumberModel with the specified value, minimum/maximum bounds, and stepSize.
				</description>
				
			</method>
			<method>
				<name>
					public SpinnerNumberModel()
				</name>
				<description>
					Constructs a SpinnerNumberModel with no minimum or maximum value, stepSize equal to one, and an initial value of zero.
				</description>
				
			</method>
			<method>
				<name>
					public void setMinimum(Comparable minimum)
				</name>
				<description>
					Changes the lower bound for numbers in this sequence. If minimum is null, then there is no lower bound. No bounds checking is done here; the new minimum value may invalidate the (minimum <= value <= maximum) invariant enforced by the constructors. This is to simplify updating the model, naturally one should ensure that the invariant is true before calling the getNextValue, getPreviousValue, or setValue methods. Typically this property is a Number of the same type as the value however it's possible to use any Comparable with a compareTo method for a Number with the same type as the value. For example if value was a Long, minimum might be a Date subclass defined like this:    MyDate extends Date {  // Date already implements Comparable       public int compareTo(Long o) {           long t = getTime();           return (t < o.longValue() ? -1 : (t == o.longValue() ? 0 : 1));       }   }   This method fires a ChangeEvent if the minimum has changed.
				</description>
				
			</method>
			<method>
				<name>
					public Comparable getMinimum()
				</name>
				<description>
					Returns the first number in this sequence.
				</description>
				
			</method>
			<method>
				<name>
					public void setMaximum(Comparable maximum)
				</name>
				<description>
					Changes the upper bound for numbers in this sequence. If maximum is null, then there is no upper bound. No bounds checking is done here; the new maximum value may invalidate the (minimum <= value < maximum) invariant enforced by the constructors. This is to simplify updating the model, naturally one should ensure that the invariant is true before calling the next, previous, or setValue methods. Typically this property is a Number of the same type as the value however it's possible to use any Comparable with a compareTo method for a Number with the same type as the value. See setMinimum for an example. This method fires a ChangeEvent if the maximum has changed.
				</description>
				
			</method>
			<method>
				<name>
					public Comparable getMaximum()
				</name>
				<description>
					Returns the last number in the sequence.
				</description>
				
			</method>
			<method>
				<name>
					public void setStepSize(Number stepSize)
				</name>
				<description>
					Changes the size of the value change computed by the getNextValue and getPreviousValue methods. An IllegalArgumentException is thrown if stepSize is null. This method fires a ChangeEvent if the stepSize has changed.
				</description>
				
			</method>
			<method>
				<name>
					public Number getStepSize()
				</name>
				<description>
					Returns the size of the value change computed by the getNextValue and getPreviousValue methods.
				</description>
				
			</method>
			<method>
				<name>
					public Object getNextValue()
				</name>
				<description>
					Returns the next number in the sequence.
				</description>
				
			</method>
			<method>
				<name>
					public Object getPreviousValue()
				</name>
				<description>
					Returns the previous number in the sequence.
				</description>
				
			</method>
			<method>
				<name>
					public Number getNumber()
				</name>
				<description>
					Returns the value of the current element of the sequence.
				</description>
				
			</method>
			<method>
				<name>
					public Object getValue()
				</name>
				<description>
					Returns the value of the current element of the sequence.
				</description>
				
			</method>
			<method>
				<name>
					public void setValue(Object value)
				</name>
				<description>
					Sets the current value for this sequence. If value is null, or not a Number, an IllegalArgumentException is thrown. No bounds checking is done here; the new value may invalidate the (minimum <= value <= maximum) invariant enforced by the constructors. It's also possible to set the value to be something that wouldn't naturally occur in the sequence, i.e. a value that's not modulo the stepSize. This is to simplify updating the model, and to accommodate spinners that don't want to restrict values that have been directly entered by the user. Naturally, one should ensure that the (minimum <= value <= maximum) invariant is true before calling the next, previous, or setValue methods. This method fires a ChangeEvent if the value has changed.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
