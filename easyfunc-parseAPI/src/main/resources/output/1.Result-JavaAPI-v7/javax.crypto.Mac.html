<javaelement>
	<package>
		javax.crypto
	</package>
	<type>
		<name>
			public class Mac  extends Object  implements Cloneable
		</name>
		<description>
			This class provides the functionality of a "Message Authentication Code" (MAC) algorithm. A MAC provides a way to check the integrity of information transmitted over or stored in an unreliable medium, based on a secret key. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties. A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, e.g., MD5 or SHA-1, in combination with a secret shared key. HMAC is specified in RFC 2104. Every implementation of the Java platform is required to support the following standard Mac algorithms: HmacMD5 HmacSHA1 HmacSHA256 These algorithms are described in the Mac section of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported.
		</description>
		<methods>
			<method>
				<name>
					protected Mac(MacSpi macSpi,     Provider provider,     String algorithm)
				</name>
				<description>
					Creates a MAC object.
				</description>
				
			</method>
			<method>
				<name>
					public final String getAlgorithm()
				</name>
				<description>
					Returns the algorithm name of this Mac object. This is the same name that was specified in one of the getInstance calls that created this Mac object.
				</description>
				
			</method>
			<method>
				<name>
					public static final Mac getInstance(String algorithm)                               throws NoSuchAlgorithmException
				</name>
				<description>
					Returns a Mac object that implements the specified MAC algorithm. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Mac object encapsulating the MacSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
				</description>
				
			</method>
			<method>
				<name>
					public static final Mac getInstance(String algorithm,                String provider)                               throws NoSuchAlgorithmException,                                      NoSuchProviderException
				</name>
				<description>
					Returns a Mac object that implements the specified MAC algorithm. A new Mac object encapsulating the MacSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the Security.getProviders() method.
				</description>
				
			</method>
			<method>
				<name>
					public static final Mac getInstance(String algorithm,                Provider provider)                               throws NoSuchAlgorithmException
				</name>
				<description>
					Returns a Mac object that implements the specified MAC algorithm. A new Mac object encapsulating the MacSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.
				</description>
				
			</method>
			<method>
				<name>
					public final Provider getProvider()
				</name>
				<description>
					Returns the provider of this Mac object.
				</description>
				
			</method>
			<method>
				<name>
					public final int getMacLength()
				</name>
				<description>
					Returns the length of the MAC in bytes.
				</description>
				
			</method>
			<method>
				<name>
					public final void init(Key key)                  throws InvalidKeyException
				</name>
				<description>
					Initializes this Mac object with the given key.
				</description>
				
			</method>
			<method>
				<name>
					public final void init(Key key,          AlgorithmParameterSpec params)                  throws InvalidKeyException,                         InvalidAlgorithmParameterException
				</name>
				<description>
					Initializes this Mac object with the given key and algorithm parameters.
				</description>
				
			</method>
			<method>
				<name>
					public final void update(byte input)                    throws IllegalStateException
				</name>
				<description>
					Processes the given byte.
				</description>
				
			</method>
			<method>
				<name>
					public final void update(byte[] input)                    throws IllegalStateException
				</name>
				<description>
					Processes the given array of bytes.
				</description>
				
			</method>
			<method>
				<name>
					public final void update(byte[] input,            int offset,            int len)                    throws IllegalStateException
				</name>
				<description>
					Processes the first len bytes in input, starting at offset inclusive.
				</description>
				
			</method>
			<method>
				<name>
					public final void update(ByteBuffer input)
				</name>
				<description>
					Processes input.remaining() bytes in the ByteBuffer input, starting at input.position(). Upon return, the buffer's position will be equal to its limit; its limit will not have changed.
				</description>
				
			</method>
			<method>
				<name>
					public final byte[] doFinal()                       throws IllegalStateException
				</name>
				<description>
					Finishes the MAC operation. A call to this method resets this Mac object to the state it was in when previously initialized via a call to init(Key) or init(Key, AlgorithmParameterSpec). That is, the object is reset and available to generate another MAC from the same key, if desired, via new calls to update and doFinal. (In order to reuse this Mac object with a different key, it must be reinitialized via a call to init(Key) or init(Key, AlgorithmParameterSpec).
				</description>
				
			</method>
			<method>
				<name>
					public final void doFinal(byte[] output,             int outOffset)                     throws ShortBufferException,                            IllegalStateException
				</name>
				<description>
					Finishes the MAC operation. A call to this method resets this Mac object to the state it was in when previously initialized via a call to init(Key) or init(Key, AlgorithmParameterSpec). That is, the object is reset and available to generate another MAC from the same key, if desired, via new calls to update and doFinal. (In order to reuse this Mac object with a different key, it must be reinitialized via a call to init(Key) or init(Key, AlgorithmParameterSpec). The MAC result is stored in output, starting at outOffset inclusive.
				</description>
				
			</method>
			<method>
				<name>
					public final byte[] doFinal(byte[] input)                       throws IllegalStateException
				</name>
				<description>
					Processes the given array of bytes and finishes the MAC operation. A call to this method resets this Mac object to the state it was in when previously initialized via a call to init(Key) or init(Key, AlgorithmParameterSpec). That is, the object is reset and available to generate another MAC from the same key, if desired, via new calls to update and doFinal. (In order to reuse this Mac object with a different key, it must be reinitialized via a call to init(Key) or init(Key, AlgorithmParameterSpec).
				</description>
				
			</method>
			<method>
				<name>
					public final void reset()
				</name>
				<description>
					Resets this Mac object. A call to this method resets this Mac object to the state it was in when previously initialized via a call to init(Key) or init(Key, AlgorithmParameterSpec). That is, the object is reset and available to generate another MAC from the same key, if desired, via new calls to update and doFinal. (In order to reuse this Mac object with a different key, it must be reinitialized via a call to init(Key) or init(Key, AlgorithmParameterSpec).
				</description>
				
			</method>
			<method>
				<name>
					public final Object clone()                     throws CloneNotSupportedException
				</name>
				<description>
					Returns a clone if the provider implementation is cloneable.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
