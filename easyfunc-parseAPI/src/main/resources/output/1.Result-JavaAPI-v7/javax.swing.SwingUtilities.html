<javaelement>
	<package>
		javax.swing
	</package>
	<type>
		<name>
			public class SwingUtilities  extends Object  implements SwingConstants
		</name>
		<description>
			A collection of utility methods for Swing.
		</description>
		<methods>
			<method>
				<name>
					public static final boolean isRectangleContainingRectangle(Rectangle a,                                       Rectangle b)
				</name>
				<description>
					Return true if a contains b
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle getLocalBounds(Component aComponent)
				</name>
				<description>
					Return the rectangle (0,0,bounds.width,bounds.height) for the component aComponent
				</description>
				
			</method>
			<method>
				<name>
					public static Window getWindowAncestor(Component c)
				</name>
				<description>
					Returns the first Window ancestor of c, or null if c is not contained inside a Window.
				</description>
				
			</method>
			<method>
				<name>
					public static Point convertPoint(Component source,                   Point aPoint,                   Component destination)
				</name>
				<description>
					Convert a aPoint in source coordinate system to destination coordinate system. If source is null, aPoint is assumed to be in destination's root component coordinate system. If destination is null, aPoint will be converted to source's root component coordinate system. If both source and destination are null, return aPoint without any conversion.
				</description>
				
			</method>
			<method>
				<name>
					public static Point convertPoint(Component source,                   int x,                   int y,                   Component destination)
				</name>
				<description>
					Convert the point (x,y) in source coordinate system to destination coordinate system. If source is null, (x,y) is assumed to be in destination's root component coordinate system. If destination is null, (x,y) will be converted to source's root component coordinate system. If both source and destination are null, return (x,y) without any conversion.
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle convertRectangle(Component source,                           Rectangle aRectangle,                           Component destination)
				</name>
				<description>
					Convert the rectangle aRectangle in source coordinate system to destination coordinate system. If source is null, aRectangle is assumed to be in destination's root component coordinate system. If destination is null, aRectangle will be converted to source's root component coordinate system. If both source and destination are null, return aRectangle without any conversion.
				</description>
				
			</method>
			<method>
				<name>
					public static Container getAncestorOfClass(Class<?> c,                             Component comp)
				</name>
				<description>
					Convenience method for searching above comp in the component hierarchy and returns the first object of class c it finds. Can return null, if a class c cannot be found.
				</description>
				
			</method>
			<method>
				<name>
					public static Container getAncestorNamed(String name,                           Component comp)
				</name>
				<description>
					Convenience method for searching above comp in the component hierarchy and returns the first object of name it finds. Can return null, if name cannot be found.
				</description>
				
			</method>
			<method>
				<name>
					public static Component getDeepestComponentAt(Component parent,                                int x,                                int y)
				</name>
				<description>
					Returns the deepest visible descendent Component of parent that contains the location x, y. If parent does not contain the specified location, then null is returned. If parent is not a container, or none of parent's visible descendents contain the specified location, parent is returned.
				</description>
				
			</method>
			<method>
				<name>
					public static MouseEvent convertMouseEvent(Component source,                             MouseEvent sourceEvent,                             Component destination)
				</name>
				<description>
					Returns a MouseEvent similar to sourceEvent except that its x and y members have been converted to destination's coordinate system. If source is null, sourceEvent x and y members are assumed to be into destination's root component coordinate system. If destination is null, the returned MouseEvent will be in source's coordinate system. sourceEvent will not be changed. A new event is returned. the source field of the returned event will be set to destination if destination is non-null use the translateMouseEvent() method to translate a mouse event from one component to another without changing the source.
				</description>
				
			</method>
			<method>
				<name>
					public static void convertPointToScreen(Point p,                          Component c)
				</name>
				<description>
					Convert a point from a component's coordinate system to screen coordinates.
				</description>
				
			</method>
			<method>
				<name>
					public static void convertPointFromScreen(Point p,                            Component c)
				</name>
				<description>
					Convert a point from a screen coordinates to a component's coordinate system
				</description>
				
			</method>
			<method>
				<name>
					public static Window windowForComponent(Component c)
				</name>
				<description>
					Returns the first Window ancestor of c, or null if c is not contained inside a Window. Note: This method provides the same functionality as getWindowAncestor.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean isDescendingFrom(Component a,                         Component b)
				</name>
				<description>
					Return true if a component a descends from a component b
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle computeIntersection(int x,                              int y,                              int width,                              int height,                              Rectangle dest)
				</name>
				<description>
					Convenience to calculate the intersection of two rectangles without allocating a new rectangle. If the two rectangles don't intersect, then the returned rectangle begins at (0,0) and has zero width and height.
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle computeUnion(int x,                       int y,                       int width,                       int height,                       Rectangle dest)
				</name>
				<description>
					Convenience method that calculates the union of two rectangles without allocating a new rectangle.
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle[] computeDifference(Rectangle rectA,                              Rectangle rectB)
				</name>
				<description>
					Convenience returning an array of rect representing the regions within rectA that do not overlap with rectB. If the two Rects do not overlap, returns an empty array
				</description>
				
			</method>
			<method>
				<name>
					public static boolean isLeftMouseButton(MouseEvent anEvent)
				</name>
				<description>
					Returns true if the mouse event specifies the left mouse button.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean isMiddleMouseButton(MouseEvent anEvent)
				</name>
				<description>
					Returns true if the mouse event specifies the middle mouse button.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean isRightMouseButton(MouseEvent anEvent)
				</name>
				<description>
					Returns true if the mouse event specifies the right mouse button.
				</description>
				
			</method>
			<method>
				<name>
					public static int computeStringWidth(FontMetrics fm,                       String str)
				</name>
				<description>
					Compute the width of the string using a font with the specified "metrics" (sizes).
				</description>
				
			</method>
			<method>
				<name>
					public static String layoutCompoundLabel(JComponent c,                           FontMetrics fm,                           String text,                           Icon icon,                           int verticalAlignment,                           int horizontalAlignment,                           int verticalTextPosition,                           int horizontalTextPosition,                           Rectangle viewR,                           Rectangle iconR,                           Rectangle textR,                           int textIconGap)
				</name>
				<description>
					Compute and return the location of the icons origin, the location of origin of the text baseline, and a possibly clipped version of the compound labels string. Locations are computed relative to the viewR rectangle. The JComponents orientation (LEADING/TRAILING) will also be taken into account and translated into LEFT/RIGHT values accordingly.
				</description>
				
			</method>
			<method>
				<name>
					public static String layoutCompoundLabel(FontMetrics fm,                           String text,                           Icon icon,                           int verticalAlignment,                           int horizontalAlignment,                           int verticalTextPosition,                           int horizontalTextPosition,                           Rectangle viewR,                           Rectangle iconR,                           Rectangle textR,                           int textIconGap)
				</name>
				<description>
					Compute and return the location of the icons origin, the location of origin of the text baseline, and a possibly clipped version of the compound labels string. Locations are computed relative to the viewR rectangle. This layoutCompoundLabel() does not know how to handle LEADING/TRAILING values in horizontalTextPosition (they will default to RIGHT) and in horizontalAlignment (they will default to CENTER). Use the other version of layoutCompoundLabel() instead.
				</description>
				
			</method>
			<method>
				<name>
					public static void paintComponent(Graphics g,                    Component c,                    Container p,                    int x,                    int y,                    int w,                    int h)
				</name>
				<description>
					Paints a component to the specified Graphics. This method is primarily useful to render Components that don't exist as part of the visible containment hierarchy, but are used for rendering. For example, if you are doing your own rendering and want to render some text (or even HTML), you could make use of JLabel's text rendering support and have it paint directly by way of this method, without adding the label to the visible containment hierarchy. This method makes use of CellRendererPane to handle the actual painting, and is only recommended if you use one component for rendering. If you make use of multiple components to handle the rendering, as JTable does, use CellRendererPane directly. Otherwise, as described below, you could end up with a CellRendererPane per Component. If c's parent is not a CellRendererPane, a new CellRendererPane is created, c is added to it, and the CellRendererPane is added to p. If c's parent is a CellRendererPane and the CellRendererPanes parent is not p, it is added to p. The component should either descend from JComponent or be another kind of lightweight component. A lightweight component is one whose "lightweight" property (returned by the Component isLightweight method) is true. If the Component is not lightweight, bad things map happen: crashes, exceptions, painting problems...
				</description>
				
			</method>
			<method>
				<name>
					public static void paintComponent(Graphics g,                    Component c,                    Container p,                    Rectangle r)
				</name>
				<description>
					Paints a component to the specified Graphics. This is a cover method for paintComponent(Graphics,Component,Container,int,int,int,int). Refer to it for more information.
				</description>
				
			</method>
			<method>
				<name>
					public static void updateComponentTreeUI(Component c)
				</name>
				<description>
					A simple minded look and feel change: ask each node in the tree to updateUI() -- that is, to initialize its UI property with the current look and feel.
				</description>
				
			</method>
			<method>
				<name>
					public static void invokeLater(Runnable doRun)
				</name>
				<description>
					Causes doRun.run() to be executed asynchronously on the AWT event dispatching thread. This will happen after all pending AWT events have been processed. This method should be used when an application thread needs to update the GUI. In the following example the invokeLater call queues the Runnable object doHelloWorld on the event dispatching thread and then prints a message.    Runnable doHelloWorld = new Runnable() {       public void run() {           System.out.println("Hello World on " + Thread.currentThread());       }   };     SwingUtilities.invokeLater(doHelloWorld);   System.out.println("This might well be displayed before the other message.");   If invokeLater is called from the event dispatching thread -- for example, from a JButton's ActionListener -- the doRun.run() will still be deferred until all pending events have been processed. Note that if the doRun.run() throws an uncaught exception the event dispatching thread will unwind (not the current thread). Additional documentation and examples for this method can be found in How to Use Threads, in The Java Tutorial. As of 1.3 this method is just a cover for java.awt.EventQueue.invokeLater(). Unlike the rest of Swing, this method can be invoked from any thread.
				</description>
				
			</method>
			<method>
				<name>
					public static void invokeAndWait(Runnable doRun)                            throws InterruptedException,                                   InvocationTargetException
				</name>
				<description>
					Causes doRun.run() to be executed synchronously on the AWT event dispatching thread. This call blocks until all pending AWT events have been processed and (then) doRun.run() returns. This method should be used when an application thread needs to update the GUI. It shouldn't be called from the event dispatching thread. Here's an example that creates a new application thread that uses invokeAndWait to print a string from the event dispatching thread and then, when that's finished, print a string from the application thread.    final Runnable doHelloWorld = new Runnable() {       public void run() {           System.out.println("Hello World on " + Thread.currentThread());       }   };     Thread appThread = new Thread() {       public void run() {           try {               SwingUtilities.invokeAndWait(doHelloWorld);           }           catch (Exception e) {               e.printStackTrace();           }           System.out.println("Finished on " + Thread.currentThread());       }   };   appThread.start();   Note that if the Runnable.run method throws an uncaught exception (on the event dispatching thread) it's caught and rethrown, as an InvocationTargetException, on the caller's thread. Additional documentation and examples for this method can be found in How to Use Threads, in The Java Tutorial. As of 1.3 this method is just a cover for java.awt.EventQueue.invokeAndWait().
				</description>
				
			</method>
			<method>
				<name>
					public static boolean isEventDispatchThread()
				</name>
				<description>
					Returns true if the current thread is an AWT event dispatching thread. As of 1.3 this method is just a cover for java.awt.EventQueue.isDispatchThread().
				</description>
				
			</method>
			<method>
				<name>
					public static int getAccessibleIndexInParent(Component c)
				</name>
				<description>
					Get the index of this object in its accessible parent. Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.
				</description>
				
			</method>
			<method>
				<name>
					public static Accessible getAccessibleAt(Component c,                           Point p)
				</name>
				<description>
					Returns the Accessible child contained at the local coordinate Point, if one exists. Otherwise returns null.
				</description>
				
			</method>
			<method>
				<name>
					public static AccessibleStateSet getAccessibleStateSet(Component c)
				</name>
				<description>
					Get the state of this object. Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.
				</description>
				
			</method>
			<method>
				<name>
					public static int getAccessibleChildrenCount(Component c)
				</name>
				<description>
					Returns the number of accessible children in the object. If all of the children of this object implement Accessible, than this method should return the number of children of this object. Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.
				</description>
				
			</method>
			<method>
				<name>
					public static Accessible getAccessibleChild(Component c,                              int i)
				</name>
				<description>
					Return the nth Accessible child of the object. Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.
				</description>
				
			</method>
			<method>
				<name>
					@Deprecated  public static Component findFocusOwner(Component c)
				</name>
				<description>
					Deprecated. As of 1.4, replaced by KeyboardFocusManager.getFocusOwner(). Return the child Component of the specified Component that is the focus owner, if any.
				</description>
				
			</method>
			<method>
				<name>
					public static JRootPane getRootPane(Component c)
				</name>
				<description>
					If c is a JRootPane descendant return its JRootPane ancestor. If c is a RootPaneContainer then return its JRootPane.
				</description>
				
			</method>
			<method>
				<name>
					public static Component getRoot(Component c)
				</name>
				<description>
					Returns the root component for the current component tree.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean processKeyBindings(KeyEvent event)
				</name>
				<description>
					Process the key bindings for the Component associated with event. This method is only useful if event.getComponent() does not descend from JComponent, or your are not invoking super.processKeyEvent from within your JComponent subclass. JComponent automatically processes bindings from within its processKeyEvent method, hence you rarely need to directly invoke this method.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean notifyAction(Action action,                     KeyStroke ks,                     KeyEvent event,                     Object sender,                     int modifiers)
				</name>
				<description>
					Invokes actionPerformed on action if action is enabled (and non-null). The command for the ActionEvent is determined by: If the action was registered via registerKeyboardAction, then the command string passed in (null will be used if null was passed in). Action value with name Action.ACTION_COMMAND_KEY, unless null. String value of the KeyEvent, unless getKeyChar returns KeyEvent.CHAR_UNDEFINED.. This will return true if action is non-null and actionPerformed is invoked on it.
				</description>
				
			</method>
			<method>
				<name>
					public static void replaceUIInputMap(JComponent component,                       int type,                       InputMap uiInputMap)
				</name>
				<description>
					Convenience method to change the UI InputMap for component to uiInputMap. If uiInputMap is null, this removes any previously installed UI InputMap.
				</description>
				
			</method>
			<method>
				<name>
					public static void replaceUIActionMap(JComponent component,                        ActionMap uiActionMap)
				</name>
				<description>
					Convenience method to change the UI ActionMap for component to uiActionMap. If uiActionMap is null, this removes any previously installed UI ActionMap.
				</description>
				
			</method>
			<method>
				<name>
					public static InputMap getUIInputMap(JComponent component,                       int condition)
				</name>
				<description>
					Returns the InputMap provided by the UI for condition condition in component component. This will return null if the UI has not installed a InputMap of the specified type.
				</description>
				
			</method>
			<method>
				<name>
					public static ActionMap getUIActionMap(JComponent component)
				</name>
				<description>
					Returns the ActionMap provided by the UI in component component. This will return null if the UI has not installed an ActionMap.
				</description>
				
			</method>
			<method>
				<name>
					public static Rectangle calculateInnerArea(JComponent c,                             Rectangle r)
				</name>
				<description>
					Stores the position and size of the inner painting area of the specified component in r and returns r. The position and size specify the bounds of the component, adjusted so as not to include the border area (the insets). This method is useful for classes that implement painting code.
				</description>
				
			</method>
			<method>
				<name>
					public static Container getUnwrappedParent(Component component)
				</name>
				<description>
					Returns the first ancestor of the component which is not an instance of JLayer.
				</description>
				
			</method>
			<method>
				<name>
					public static Component getUnwrappedView(JViewport viewport)
				</name>
				<description>
					Returns the first JViewport's descendant which is not an instance of JLayer. If such a descendant can not be found, null is returned. If the viewport's view component is not a JLayer, this method is equivalent to JViewport.getView() otherwise JLayer.getView() will be recursively called on all descending JLayers.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
