<javaelement>
	<package>
		javax.swing
	</package>
	<type>
		<name>
			public class JDesktopPane  extends JLayeredPane  implements Accessible
		</name>
		<description>
			A container used to create a multiple-document interface or a virtual desktop. You create JInternalFrame objects and add them to the JDesktopPane. JDesktopPane extends JLayeredPane to manage the potentially overlapping internal frames. It also maintains a reference to an instance of DesktopManager that is set by the UI class for the current look and feel (L&F). Note that JDesktopPane does not support borders. This class is normally used as the parent of JInternalFrames to provide a pluggable DesktopManager object to the JInternalFrames. The installUI of the L&F specific implementation is responsible for setting the desktopManager variable appropriately. When the parent of a JInternalFrame is a JDesktopPane, it should delegate most of its behavior to the desktopManager (closing, resizing, etc). For further documentation and examples see How to Use Internal Frames, a section in The Java Tutorial. Warning: Swing is not thread safe. For more information see Swing's Threading Policy. Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansTM has been added to the java.beans package. Please see XMLEncoder.
		</description>
		<methods>
			<method>
				<name>
					public static final int LIVE_DRAG_MODE
				</name>
				<description>
					Indicates that the entire contents of the item being dragged should appear inside the desktop pane.
				</description>
				
			</method>
			<method>
				<name>
					public static final int OUTLINE_DRAG_MODE
				</name>
				<description>
					Indicates that an outline only of the item being dragged should appear inside the desktop pane.
				</description>
				
			</method>
			<method>
				<name>
					public JDesktopPane()
				</name>
				<description>
					Creates a new JDesktopPane.
				</description>
				
			</method>
			<method>
				<name>
					public DesktopPaneUI getUI()
				</name>
				<description>
					Returns the L&F object that renders this component.
				</description>
				
			</method>
			<method>
				<name>
					public void setUI(DesktopPaneUI ui)
				</name>
				<description>
					Sets the L&F object that renders this component.
				</description>
				
			</method>
			<method>
				<name>
					public void setDragMode(int dragMode)
				</name>
				<description>
					Sets the "dragging style" used by the desktop pane. You may want to change to one mode or another for performance or aesthetic reasons.
				</description>
				
			</method>
			<method>
				<name>
					public int getDragMode()
				</name>
				<description>
					Gets the current "dragging style" used by the desktop pane.
				</description>
				
			</method>
			<method>
				<name>
					public DesktopManager getDesktopManager()
				</name>
				<description>
					Returns the DesktopManger that handles desktop-specific UI actions.
				</description>
				
			</method>
			<method>
				<name>
					public void setDesktopManager(DesktopManager d)
				</name>
				<description>
					Sets the DesktopManger that will handle desktop-specific UI actions. This may be overridden by LookAndFeel.
				</description>
				
			</method>
			<method>
				<name>
					public void updateUI()
				</name>
				<description>
					Notification from the UIManager that the L&F has changed. Replaces the current UI object with the latest version from the UIManager.
				</description>
				
			</method>
			<method>
				<name>
					public String getUIClassID()
				</name>
				<description>
					Returns the name of the L&F class that renders this component.
				</description>
				
			</method>
			<method>
				<name>
					public JInternalFrame[] getAllFrames()
				</name>
				<description>
					Returns all JInternalFrames currently displayed in the desktop. Returns iconified frames as well as expanded frames.
				</description>
				
			</method>
			<method>
				<name>
					public JInternalFrame getSelectedFrame()
				</name>
				<description>
					Returns the currently active JInternalFrame in this JDesktopPane, or null if no JInternalFrame is currently active.
				</description>
				
			</method>
			<method>
				<name>
					public void setSelectedFrame(JInternalFrame f)
				</name>
				<description>
					Sets the currently active JInternalFrame in this JDesktopPane. This method is used to bridge the package gap between JDesktopPane and the platform implementation code and should not be called directly. To visually select the frame the client must call JInternalFrame.setSelected(true) to activate the frame.
				</description>
				
			</method>
			<method>
				<name>
					public JInternalFrame[] getAllFramesInLayer(int layer)
				</name>
				<description>
					Returns all JInternalFrames currently displayed in the specified layer of the desktop. Returns iconified frames as well expanded frames.
				</description>
				
			</method>
			<method>
				<name>
					public JInternalFrame selectFrame(boolean forward)
				</name>
				<description>
					Selects the next JInternalFrame in this desktop pane.
				</description>
				
			</method>
			<method>
				<name>
					protected void addImpl(Component comp,             Object constraints,             int index)
				</name>
				<description>
					Adds the specified component to this container at the specified index. This method also notifies the layout manager to add the component to this container's layout using the specified constraints object via the addLayoutComponent method. The constraints are defined by the particular layout manager being used. For example, the BorderLayout class defines five constraints: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST, and BorderLayout.CENTER. The GridBagLayout class requires a GridBagConstraints object. Failure to pass the correct type of constraints object results in an IllegalArgumentException. If the current layout manager implements LayoutManager2, then LayoutManager2.addLayoutComponent(Component,Object) is invoked on it. If the current layout manager does not implement LayoutManager2, and constraints is a String, then LayoutManager.addLayoutComponent(String,Component) is invoked on it. If the component is not an ancestor of this container and has a non-null parent, it is removed from its current parent before it is added to this container. This is the method to override if a program needs to track every add request to a container as all other add methods defer to this one. An overriding method should usually include a call to the superclass's version of the method: super.addImpl(comp, constraints, index) This method changes layout-related information, and therefore, invalidates the component hierarchy. If the container has already been displayed, the hierarchy must be validated thereafter in order to display the added component.
				</description>
				
			</method>
			<method>
				<name>
					public void remove(int index)
				</name>
				<description>
					Remove the indexed component from this pane. This is the absolute index, ignoring layers.
				</description>
				
			</method>
			<method>
				<name>
					public void removeAll()
				</name>
				<description>
					Removes all the components from this container.
				</description>
				
			</method>
			<method>
				<name>
					public void setComponentZOrder(Component comp,                        int index)
				</name>
				<description>
					Moves the specified component to the specified z-order index in the container. The z-order determines the order that components are painted; the component with the highest z-order paints first and the component with the lowest z-order paints last. Where components overlap, the component with the lower z-order paints over the component with the higher z-order. If the component is a child of some other container, it is removed from that container before being added to this container. The important difference between this method and java.awt.Container.add(Component, int) is that this method doesn't call removeNotify on the component while removing it from its previous container unless necessary and when allowed by the underlying native windowing system. This way, if the component has the keyboard focus, it maintains the focus when moved to the new position. This property is guaranteed to apply only to lightweight non-Container components. This method changes layout-related information, and therefore, invalidates the component hierarchy. Note: Not all platforms support changing the z-order of heavyweight components from one container into another without the call to removeNotify. There is no way to detect whether a platform supports this, so developers shouldn't make any assumptions.
				</description>
				
			</method>
			<method>
				<name>
					protected String paramString()
				</name>
				<description>
					Returns a string representation of this JDesktopPane. This method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between implementations. The returned string may be empty but may not be null.
				</description>
				
			</method>
			<method>
				<name>
					public AccessibleContext getAccessibleContext()
				</name>
				<description>
					Gets the AccessibleContext associated with this JDesktopPane. For desktop panes, the AccessibleContext takes the form of an AccessibleJDesktopPane. A new AccessibleJDesktopPane instance is created if necessary.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
