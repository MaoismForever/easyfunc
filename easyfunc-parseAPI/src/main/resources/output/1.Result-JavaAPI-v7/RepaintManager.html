<javaelement>
	<package>
		javax.swing
	</package>
	<type>
		<name>
			public class RepaintManager  extends Object
		</name>
		<description>
			This class manages repaint requests, allowing the number of repaints to be minimized, for example by collapsing multiple requests into a single repaint for members of a component tree. As of 1.6 RepaintManager handles repaint requests for Swing's top level components (JApplet, JWindow, JFrame and JDialog). Any calls to repaint on one of these will call into the appropriate addDirtyRegion method.
		</description>
		<methods>
			<method>
				<name>
					public RepaintManager()
				</name>
				<description>
					Create a new RepaintManager instance. You rarely call this constructor. directly. To get the default RepaintManager, use RepaintManager.currentManager(JComponent) (normally "this").
				</description>
				
			</method>
			<method>
				<name>
					public static RepaintManager currentManager(Component c)
				</name>
				<description>
					Return the RepaintManager for the calling thread given a Component.
				</description>
				
			</method>
			<method>
				<name>
					public static RepaintManager currentManager(JComponent c)
				</name>
				<description>
					Return the RepaintManager for the calling thread given a JComponent. Note: This method exists for backward binary compatibility with earlier versions of the Swing library. It simply returns the result returned by currentManager(Component).
				</description>
				
			</method>
			<method>
				<name>
					public static void setCurrentManager(RepaintManager aRepaintManager)
				</name>
				<description>
					Set the RepaintManager that should be used for the calling thread. aRepaintManager will become the current RepaintManager for the calling thread's thread group.
				</description>
				
			</method>
			<method>
				<name>
					public void addInvalidComponent(JComponent invalidComponent)
				</name>
				<description>
					Mark the component as in need of layout and queue a runnable for the event dispatching thread that will validate the components first isValidateRoot() ancestor.
				</description>
				
			</method>
			<method>
				<name>
					public void removeInvalidComponent(JComponent component)
				</name>
				<description>
					Remove a component from the list of invalid components.
				</description>
				
			</method>
			<method>
				<name>
					public void addDirtyRegion(JComponent c,                    int x,                    int y,                    int w,                    int h)
				</name>
				<description>
					Add a component in the list of components that should be refreshed. If c already has a dirty region, the rectangle (x,y,w,h) will be unioned with the region that should be redrawn.
				</description>
				
			</method>
			<method>
				<name>
					public void addDirtyRegion(Window window,                    int x,                    int y,                    int w,                    int h)
				</name>
				<description>
					Adds window to the list of Components that need to be repainted.
				</description>
				
			</method>
			<method>
				<name>
					public void addDirtyRegion(Applet applet,                    int x,                    int y,                    int w,                    int h)
				</name>
				<description>
					Adds applet to the list of Components that need to be repainted.
				</description>
				
			</method>
			<method>
				<name>
					public Rectangle getDirtyRegion(JComponent aComponent)
				</name>
				<description>
					Return the current dirty region for a component. Return an empty rectangle if the component is not dirty.
				</description>
				
			</method>
			<method>
				<name>
					public void markCompletelyDirty(JComponent aComponent)
				</name>
				<description>
					Mark a component completely dirty. aComponent will be completely painted during the next paintDirtyRegions() call.
				</description>
				
			</method>
			<method>
				<name>
					public void markCompletelyClean(JComponent aComponent)
				</name>
				<description>
					Mark a component completely clean. aComponent will not get painted during the next paintDirtyRegions() call.
				</description>
				
			</method>
			<method>
				<name>
					public boolean isCompletelyDirty(JComponent aComponent)
				</name>
				<description>
					Convenience method that returns true if aComponent will be completely painted during the next paintDirtyRegions(). If computing dirty regions is expensive for your component, use this method and avoid computing dirty region if it return true.
				</description>
				
			</method>
			<method>
				<name>
					public void validateInvalidComponents()
				</name>
				<description>
					Validate all of the components that have been marked invalid.
				</description>
				
			</method>
			<method>
				<name>
					public void paintDirtyRegions()
				</name>
				<description>
					Paint all of the components that have been marked dirty.
				</description>
				
			</method>
			<method>
				<name>
					public String toString()
				</name>
				<description>
					Returns a string that displays and identifies this object's properties.
				</description>
				
			</method>
			<method>
				<name>
					public Image getOffscreenBuffer(Component c,                         int proposedWidth,                         int proposedHeight)
				</name>
				<description>
					Return the offscreen buffer that should be used as a double buffer with the component c. By default there is a double buffer per RepaintManager. The buffer might be smaller than (proposedWidth,proposedHeight) This happens when the maximum double buffer size as been set for the receiving repaint manager.
				</description>
				
			</method>
			<method>
				<name>
					public Image getVolatileOffscreenBuffer(Component c,                                 int proposedWidth,                                 int proposedHeight)
				</name>
				<description>
					Return a volatile offscreen buffer that should be used as a double buffer with the specified component c. The image returned will be an instance of VolatileImage, or null if a VolatileImage object could not be instantiated. This buffer might be smaller than (proposedWidth,proposedHeight). This happens when the maximum double buffer size has been set for this repaint manager.
				</description>
				
			</method>
			<method>
				<name>
					public void setDoubleBufferMaximumSize(Dimension d)
				</name>
				<description>
					Set the maximum double buffer size.
				</description>
				
			</method>
			<method>
				<name>
					public Dimension getDoubleBufferMaximumSize()
				</name>
				<description>
					Returns the maximum double buffer size.
				</description>
				
			</method>
			<method>
				<name>
					public void setDoubleBufferingEnabled(boolean aFlag)
				</name>
				<description>
					Enables or disables double buffering in this RepaintManager. CAUTION: The default value for this property is set for optimal paint performance on the given platform and it is not recommended that programs modify this property directly.
				</description>
				
			</method>
			<method>
				<name>
					public boolean isDoubleBufferingEnabled()
				</name>
				<description>
					Returns true if this RepaintManager is double buffered. The default value for this property may vary from platform to platform. On platforms where native double buffering is supported in the AWT, the default value will be false to avoid unnecessary buffering in Swing. On platforms where native double buffering is not supported, the default value will be true.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
