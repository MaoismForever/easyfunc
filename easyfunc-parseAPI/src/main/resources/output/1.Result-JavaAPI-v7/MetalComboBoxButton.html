<javaelement>
	<package>
		javax.swing.plaf.metal
	</package>
	<type>
		<name>
			public class MetalComboBoxButton  extends JButton
		</name>
		<description>
			JButton subclass to help out MetalComboBoxUI Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansTM has been added to the java.beans package. Please see XMLEncoder.
		</description>
		<methods>
			<method>
				<name>
					protected JComboBox comboBox
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					protected JList listBox
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					protected CellRendererPane rendererPane
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					protected Icon comboIcon
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					protected boolean iconOnly
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public MetalComboBoxButton(JComboBox cb,                     Icon i,                     CellRendererPane pane,                     JList list)
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public MetalComboBoxButton(JComboBox cb,                     Icon i,                     boolean onlyIcon,                     CellRendererPane pane,                     JList list)
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final JComboBox getComboBox()
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final void setComboBox(JComboBox cb)
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final Icon getComboIcon()
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final void setComboIcon(Icon i)
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final boolean isIconOnly()
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public final void setIconOnly(boolean isIconOnly)
				</name>
				<description>
					null
				</description>
				
			</method>
			<method>
				<name>
					public boolean isFocusTraversable()
				</name>
				<description>
					Description copied from class: Component Returns whether this Component can become the focus owner.
				</description>
				
			</method>
			<method>
				<name>
					public void setEnabled(boolean enabled)
				</name>
				<description>
					Description copied from class: AbstractButton Enables (or disables) the button.
				</description>
				
			</method>
			<method>
				<name>
					public void paintComponent(Graphics g)
				</name>
				<description>
					Description copied from class: JComponent Calls the UI delegate's paint method, if the UI delegate is non-null. We pass the delegate a copy of the Graphics object to protect the rest of the paint code from irrevocable changes (for example, Graphics.translate). If you override this in a subclass you should not make permanent changes to the passed in Graphics. For example, you should not alter the clip Rectangle or modify the transform. If you need to do these operations you may find it easier to create a new Graphics from the passed in Graphics and manipulate it. Further, if you do not invoker super's implementation you must honor the opaque property, that is if this component is opaque, you must completely fill in the background in a non-opaque color. If you do not honor the opaque property you will likely see visual artifacts. The passed in Graphics object might have a transform other than the identify transform installed on it. In this case, you might get unexpected results if you cumulatively apply another transform.
				</description>
				
			</method>
			<method>
				<name>
					public Dimension getMinimumSize()
				</name>
				<description>
					Description copied from class: JComponent If the minimum size has been set to a non-null value just returns it. If the UI delegate's getMinimumSize method returns a non-null value then return that; otherwise defer to the component's layout manager.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
