<javaelement>
	<package>
		javax.swing
	</package>
	<type>
		<name>
			public interface RootPaneContainer
		</name>
		<description>
			This interface is implemented by components that have a single JRootPane child: JDialog, JFrame, JWindow, JApplet, JInternalFrame. The methods in this interface are just covers for the JRootPane properties, e.g. getContentPane() is generally implemented like this:        public Container getContentPane() {           return getRootPane().getContentPane();       }   This interface serves as a marker for Swing GUI builders that need to treat components like JFrame, that contain a single JRootPane, specially. For example in a GUI builder, dropping a component on a RootPaneContainer would be interpreted as frame.getContentPane().add(child). For conveniance JFrame, JDialog, JWindow, JApplet and JInternalFrame, by default, forward, by default, all calls to the add, remove and setLayout methods, to the contentPane. This means you can call:    rootPaneContainer.add(component);   instead of:    rootPaneContainer.getContentPane().add(component);   The behavior of the add and setLayout methods for JFrame, JDialog, JWindow, JApplet and JInternalFrame is controlled by the rootPaneCheckingEnabled property. If this property is true (the default), then calls to these methods are forwarded to the contentPane; if false, these methods operate directly on the RootPaneContainer. This property is only intended for subclasses, and is therefore protected.
		</description>
		<methods>
			<method>
				<name>
					JRootPane getRootPane()
				</name>
				<description>
					Return this component's single JRootPane child. A conventional implementation of this interface will have all of the other methods indirect through this one. The rootPane has two children: the glassPane and the layeredPane.
				</description>
				
			</method>
			<method>
				<name>
					void setContentPane(Container contentPane)
				</name>
				<description>
					The "contentPane" is the primary container for application specific components. Applications should add children to the contentPane, set its layout manager, and so on. The contentPane may not be null. Generally implemented with getRootPane().setContentPane(contentPane);
				</description>
				
			</method>
			<method>
				<name>
					Container getContentPane()
				</name>
				<description>
					Returns the contentPane.
				</description>
				
			</method>
			<method>
				<name>
					void setLayeredPane(JLayeredPane layeredPane)
				</name>
				<description>
					A Container that manages the contentPane and in some cases a menu bar. The layeredPane can be used by descendants that want to add a child to the RootPaneContainer that isn't layout managed. For example an internal dialog or a drag and drop effect component. The layeredPane may not be null. Generally implemented with       getRootPane().setLayeredPane(layeredPane);
				</description>
				
			</method>
			<method>
				<name>
					JLayeredPane getLayeredPane()
				</name>
				<description>
					Returns the layeredPane.
				</description>
				
			</method>
			<method>
				<name>
					void setGlassPane(Component glassPane)
				</name>
				<description>
					The glassPane is always the first child of the rootPane and the rootPanes layout manager ensures that it's always as big as the rootPane. By default it's transparent and not visible. It can be used to temporarily grab all keyboard and mouse input by adding listeners and then making it visible. by default it's not visible. The glassPane may not be null. Generally implemented with getRootPane().setGlassPane(glassPane);
				</description>
				
			</method>
			<method>
				<name>
					Component getGlassPane()
				</name>
				<description>
					Returns the glassPane.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
