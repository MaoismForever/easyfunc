<javaelement>
	<package>
		java.util
	</package>
	<type>
		<name>
			public class Arrays  extends Object
		</name>
		<description>
			This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists. The methods in this class all throw a NullPointerException, if the specified array reference is null, except where noted. The documentation for the methods contained in this class includes briefs description of the implementations. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort(Object[]) does not have to be a MergeSort, but it does have to be stable.) This class is a member of the Java Collections Framework.
		</description>
		<methods>
			<method>
				<name>
					public static void sort(int[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(int[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(long[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(long[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(short[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(short[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(char[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(char[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(byte[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(byte[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(float[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(float[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Float.compareTo(java.lang.Float): -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(double[] a)
				</name>
				<description>
					Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(double[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method Double.compareTo(java.lang.Double): -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(Object[] a)
				</name>
				<description>
					Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techiques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
				</description>
				
			</method>
			<method>
				<name>
					public static void sort(Object[] a,          int fromIndex,          int toIndex)
				</name>
				<description>
					Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techiques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
				</description>
				
			</method>
			<method>
				<name>
					public static <T> void sort(T[] a,              Comparator<? super T> c)
				</name>
				<description>
					Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techiques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
				</description>
				
			</method>
			<method>
				<name>
					public static <T> void sort(T[] a,              int fromIndex,              int toIndex,              Comparator<? super T> c)
				</name>
				<description>
					Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techiques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(long[] a,                 long key)
				</name>
				<description>
					Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(long[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(long[] a,                 int fromIndex,                 int toIndex,                 long key)
				</name>
				<description>
					Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the sort(long[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(int[] a,                 int key)
				</name>
				<description>
					Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(int[] a,                 int fromIndex,                 int toIndex,                 int key)
				</name>
				<description>
					Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort(int[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(short[] a,                 short key)
				</name>
				<description>
					Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(short[] a,                 int fromIndex,                 int toIndex,                 short key)
				</name>
				<description>
					Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the sort(short[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(char[] a,                 char key)
				</name>
				<description>
					Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(char[] a,                 int fromIndex,                 int toIndex,                 char key)
				</name>
				<description>
					Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the sort(char[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(byte[] a,                 byte key)
				</name>
				<description>
					Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(byte[] a,                 int fromIndex,                 int toIndex,                 byte key)
				</name>
				<description>
					Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(double[] a,                 double key)
				</name>
				<description>
					Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(double[] a,                 int fromIndex,                 int toIndex,                 double key)
				</name>
				<description>
					Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the sort(double[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(float[] a,                 float key)
				</name>
				<description>
					Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(float[] a,                 int fromIndex,                 int toIndex,                 float key)
				</name>
				<description>
					Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the sort(float[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(Object[] a,                 Object key)
				</name>
				<description>
					Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the sort(Object[]) method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static int binarySearch(Object[] a,                 int fromIndex,                 int toIndex,                 Object key)
				</name>
				<description>
					Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the sort(Object[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static <T> int binarySearch(T[] a,                     T key,                     Comparator<? super T> c)
				</name>
				<description>
					Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the sort(T[], Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static <T> int binarySearch(T[] a,                     int fromIndex,                     int toIndex,                     T key,                     Comparator<? super T> c)
				</name>
				<description>
					Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the sort(T[], int, int, Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(long[] a,               long[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(int[] a,               int[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(short[] a,               short[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(char[] a,               char[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(byte[] a,               byte[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(boolean[] a,               boolean[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(double[] a,               double[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two doubles d1 and d2 are considered equal if:     new Double(d1).equals(new Double(d2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0d unequal to -0.0d.)
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(float[] a,               float[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two floats f1 and f2 are considered equal if:     new Float(f1).equals(new Float(f2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0f unequal to -0.0f.)
				</description>
				
			</method>
			<method>
				<name>
					public static boolean equals(Object[] a,               Object[] a2)
				</name>
				<description>
					Returns true if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)). In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(long[] a,          long val)
				</name>
				<description>
					Assigns the specified long value to each element of the specified array of longs.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(long[] a,          int fromIndex,          int toIndex,          long val)
				</name>
				<description>
					Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(int[] a,          int val)
				</name>
				<description>
					Assigns the specified int value to each element of the specified array of ints.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(int[] a,          int fromIndex,          int toIndex,          int val)
				</name>
				<description>
					Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(short[] a,          short val)
				</name>
				<description>
					Assigns the specified short value to each element of the specified array of shorts.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(short[] a,          int fromIndex,          int toIndex,          short val)
				</name>
				<description>
					Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(char[] a,          char val)
				</name>
				<description>
					Assigns the specified char value to each element of the specified array of chars.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(char[] a,          int fromIndex,          int toIndex,          char val)
				</name>
				<description>
					Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(byte[] a,          byte val)
				</name>
				<description>
					Assigns the specified byte value to each element of the specified array of bytes.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(byte[] a,          int fromIndex,          int toIndex,          byte val)
				</name>
				<description>
					Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(boolean[] a,          boolean val)
				</name>
				<description>
					Assigns the specified boolean value to each element of the specified array of booleans.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(boolean[] a,          int fromIndex,          int toIndex,          boolean val)
				</name>
				<description>
					Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(double[] a,          double val)
				</name>
				<description>
					Assigns the specified double value to each element of the specified array of doubles.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(double[] a,          int fromIndex,          int toIndex,          double val)
				</name>
				<description>
					Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(float[] a,          float val)
				</name>
				<description>
					Assigns the specified float value to each element of the specified array of floats.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(float[] a,          int fromIndex,          int toIndex,          float val)
				</name>
				<description>
					Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(Object[] a,          Object val)
				</name>
				<description>
					Assigns the specified Object reference to each element of the specified array of Objects.
				</description>
				
			</method>
			<method>
				<name>
					public static void fill(Object[] a,          int fromIndex,          int toIndex,          Object val)
				</name>
				<description>
					Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
				</description>
				
			</method>
			<method>
				<name>
					public static <T> T[] copyOf(T[] original,               int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static <T,U> T[] copyOf(U[] original,                 int newLength,                 Class<? extends T[]> newType)
				</name>
				<description>
					Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class newType.
				</description>
				
			</method>
			<method>
				<name>
					public static byte[] copyOf(byte[] original,              int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (byte)0. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static short[] copyOf(short[] original,               int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (short)0. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static int[] copyOf(int[] original,             int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static long[] copyOf(long[] original,              int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0L. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static char[] copyOf(char[] original,              int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain '\\u000'. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static float[] copyOf(float[] original,               int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0f. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static double[] copyOf(double[] original,                int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0d. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean[] copyOf(boolean[] original,                 int newLength)
				</name>
				<description>
					Copies the specified array, truncating or padding with false (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain false. Such indices will exist if and only if the specified length is greater than that of the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static <T> T[] copyOfRange(T[] original,                    int from,                    int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of exactly the same class as the original array.
				</description>
				
			</method>
			<method>
				<name>
					public static <T,U> T[] copyOfRange(U[] original,                      int from,                      int to,                      Class<? extends T[]> newType)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of the class newType.
				</description>
				
			</method>
			<method>
				<name>
					public static byte[] copyOfRange(byte[] original,                   int from,                   int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static short[] copyOfRange(short[] original,                    int from,                    int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static int[] copyOfRange(int[] original,                  int from,                  int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static long[] copyOfRange(long[] original,                   int from,                   int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0L is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static char[] copyOfRange(char[] original,                   int from,                   int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case '\\u000' is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static float[] copyOfRange(float[] original,                    int from,                    int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0f is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static double[] copyOfRange(double[] original,                     int from,                     int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0d is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean[] copyOfRange(boolean[] original,                      int from,                      int to)
				</name>
				<description>
					Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case false is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
				</description>
				
			</method>
			<method>
				<name>
					@SafeVarargs  public static <T> List<T> asList(T... a)
				</name>
				<description>
					Returns a fixed-size list backed by the specified array. (Changes to the returned list "write through" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with Collection.toArray(). The returned list is serializable and implements RandomAccess. This method also provides a convenient way to create a fixed-size list initialized to contain several elements:        List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(long[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two long arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Long instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(int[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two non-null int arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Integer instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(short[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two short arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Short instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(char[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two char arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Character instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(byte[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two byte arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Byte instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(boolean[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two boolean arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Boolean instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(float[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two float arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Float instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(double[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. For any two double arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode method on a List containing a sequence of Double instances representing the elements of a in the same order. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static int hashCode(Object[] a)
				</name>
				<description>
					Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is equal to the value that would be returned by Arrays.asList(a).hashCode(), unless a is null, in which case 0 is returned.
				</description>
				
			</method>
			<method>
				<name>
					public static int deepHashCode(Object[] a)
				</name>
				<description>
					Returns a hash code based on the "deep contents" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays a and b such that Arrays.deepEquals(a, b), it is also the case that Arrays.deepHashCode(a) == Arrays.deepHashCode(b). The computation of the value returned by this method is similar to that of the value returned by List.hashCode() on a list containing the same elements as a in the same order, with one difference: If an element e of a is itself an array, its hash code is computed not by calling e.hashCode(), but as by calling the appropriate overloading of Arrays.hashCode(e) if e is an array of a primitive type, or as by calling Arrays.deepHashCode(e) recursively if e is an array of a reference type. If a is null, this method returns 0.
				</description>
				
			</method>
			<method>
				<name>
					public static boolean deepEquals(Object[] a1,                   Object[] a2)
				</name>
				<description>
					Returns true if the two specified arrays are deeply equal to one another. Unlike the equals(Object[],Object[]) method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are null, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold: e1 and e2 are both arrays of object reference types, and Arrays.deepEquals(e1, e2) would return true e1 and e2 are arrays of the same primitive type, and the appropriate overloading of Arrays.equals(e1, e2) would return true. e1 == e2 e1.equals(e2) would return true. Note that this definition permits null elements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(long[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(long). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(int[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(int). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(short[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(short). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(char[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(char). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(byte[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(byte). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(boolean[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(boolean). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(float[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(float). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(double[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(double). Returns "null" if a is null.
				</description>
				
			</method>
			<method>
				<name>
					public static String toString(Object[] a)
				</name>
				<description>
					Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the Object.toString() method inherited from Object, which describes their identities rather than their contents. The value returned by this method is equal to the value that would be returned by Arrays.asList(a).toString(), unless a is null, in which case "null" is returned.
				</description>
				
			</method>
			<method>
				<name>
					public static String deepToString(Object[] a)
				</name>
				<description>
					Returns a string representation of the "deep contents" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(Object), unless they are themselves arrays. If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of Arrays.toString(e). If an element e is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string "[...]". For example, an array containing only a reference to itself would be rendered as "[[...]]". This method returns "null" if the specified array is null.
				</description>
				
			</method>
			
		</methods>
		
	</type>
	
</javaelement>
